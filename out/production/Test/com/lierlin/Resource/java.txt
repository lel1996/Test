jdbc.url=jdbc:mysql://47.102.205.163:3306/testshop?characterEncoding=utf-8
1.jre是运行环境=java虚拟机（jvm）+类库
  jdk=jre+java的开发工具
2.bin目录：该目录用于存放一些可执行程序（javac.exe(java编译器)),java.exe(java运行工具),jar.exe(打包工具），
  javadoc.exe(文档生成工具)
  include目录：存放C语言的头文件
  lib目录：存放的java类库；
  db目录：java的数据库；
3.配置path是为了可以在各个盘符下都能执行javac.exe和java.exe可执行文件、
  classpath环境变量里记录的是java类的运行文件所在的目录
4.每一个系统都有对应的java虚拟机jvm
5.class是类的声明
6.源码：就是二进制定点表示法，即最高位为符号为“0”表示正，“1”表示负，其余位表示数值的大小
  反码：正数的反码与其源码相同；负数的反码是对其源码各个取反，但符号位除外
  补码：正数的补码与其源码相同；负数的补码是在其反码的末尾加一；
  计算机使用源码存储的使用补码计算的反码的作用就是把源码计算成补码用来计算
  求源码的补码：先求反码（把源码出第一个外各个位置上的数值改变）
		再求补码（在反码的末尾加上一）
7.&& a&&b(如果a为false就不执行b了)剩下的和&效果一样
  &：有0则0  |（或）：有1则1 ^（异或 两边相同为false两边不同为ture）：相同则0，不同则1 ~（逻辑非
      非false则ture，非ture则false）按位取反
8.<<:左移，向左移动几位就是乘以2的几次幂
  >>:右移：最高位是0，左边补齐0；
  >>>：无符号右移 无论最高位是0还是1，左边补齐0
9：方法：完成特定功能的代码快，增加代码的复用性
10： return不是结束循环的而是结束方法的
11：声明的方法和局部变量放在栈里面，new出的对象放在堆里面
12：基本数据类型的传值，不改变原值，因为调用后就会弹栈，局部变量随之消失
    引用数据类型的值传递，改变原值，因为即使方法弹栈，但是堆内内存数组对象还在，可以通过地址继续访问
13：面向对象特征：封装，继承，多态
14：再编译的源文件变成了字节码文件，运行的时候字节码被加载到内存中（内存中的方法区）
15：在栈中的主方法main中每一次new新的对象都会在堆中开辟新的地址。。主方法是虚拟机从方法区（内存）中
    帮我们调用的，每次调用完方法后就会被弹出栈
16：如果没有任何引用指向该对象，那么该对象就会变成垃圾java中有完善的垃圾回收机制，会在不定时对其进行回收
17：基本数据类型和引用数据类型都可以作为参数，引用数据类型就是传递的是地址
18：匿名对象只适合对方的一次调用，因为调用多次就产生多个对象（每new一次就开辟一块内存）匿名对象可以调用属性，但是没有
    意义，因为调用后就变成垃圾如果需要赋值还是用有名字对象
19：在主函数main中定义的方法都加上static在主方法main外的方法不加static
20：private（私有）用它修饰的成员变量不能在其它的类中直接赋值，要通过set变量名，get变量名来赋值，可以通过
    在set** 方法中写一些判断语句来判断在其它类中赋的值是否为安全值
21：this代表当前引用的对象引用对象记录什么地址值，this中就记录什么地址值，this调用的是成员变量（谁来调用我我就代表谁
22：javabean类也叫实体类对别的类提供服务的他可以去用来创建对象有set和get方法的类就叫java bean类
23：成员变量在类中方法外，局部变量在方法定义中和方法声明上，成员变量在堆内存（成员变量属于对象，对象进
    堆内存，局部变量在栈内存中局部变量属于方法，方法进栈内存
24：封装是指隐藏对象的属性和实现细节，仅对外提供公共的访问方式也就是提供set，get方法
25：静态的成员变量是多个对象共享一份节约内存静态的成员变量在方法区中（内存中）没有在堆中（被所有的类共享）
26：静态的方法不要创建对象直接通过类名来调用其方法，静态变量也可以通过（类名.变量）来赋值
27：静态的变量是存在方法区中的，它随着类的加载而产生，成员变量属于对象（实列变量）随着对象的创建而创建
28：public static void main(String[] args)
    public:被jvm调用，所有权限要足够大即用public
    static：被jvm调用，不需要创建对象，直接类名.**即可调用
    void：被jvm调用，不需要有任何的返回值
    main：只有这样写才能被jvm识别，但main不是关键字
    String[] args:以前是用来接受键盘录入的
29：如果一个类中所有的方法都是静态的，需要再多做一步，私有构造方法，目的是不让其他类创建本类对象，
30：构造代码块：在类中方法外（单独被大括号括起来的部分）每创建一次对象就会执行一次，优先于构造函数执行    
    静态代码块：随着类加载而加载，且只执行一次作用给类进行初始化，一般用来加载驱动（优先于主方法执行）
                在类中方法外加一个Static{代码}
31：继承只支持单继承不支持多继承，原因（有安全隐患，比如两个父类中的方法体不一样方法名一样）
32;this既可以调用本类的，也可以调用父类的（本类没有的情况下，就近原则，子类没有就不用父类的了）
   super调用父类的成员变量和方法
33：子类中的所有的构造方法默认都会访问父类中空参数的构造方法因为（子类会继承父类中的数据，可能还会使用父类的数据
     所以，子类初始化之前，一定要先完成父类数据的初始化）其实每一个构造方法的第一条语句默认都是super()Object类
     是最顶层的父类（任何的类都继承Object这个父类构造方法都默认访问Object的构造方法）
34：override和overload区别 方法的重载可以改变返回值的类型：本类中出现的方法名一样，参数列表不同的方法，与返回值无关
    方法的重写：子类中出现了和父类中方法声明一样的方法，于返回值类型有关，返回值是一致
35：父类的引用指向子类的对象，编译看左边，运行也看左边（用在成员变量上时）
                             编译看左边，运行看右边（用在方法上的时候）
                             编译看左边，运行也看左边（用在静态的方法上，这种不叫方法的重写，static是属于自己的方法）
36：抽象类不一定有抽象方法，有抽象方法的类不一定是抽象类或者是接口，抽象类不能实例化对象（可以通过父类的引用指向子类的对象来实列化抽象方法），
    抽象类的子类，要么是抽象类要么重写抽象类中的所有抽象方法；
37：在抽象类中的方法中相当于给方法加了一定的规则，不准守这个规则就出错，（编译在左边运行在右边所以抽象方法就已经
    规定了子类中的方法，一定要重写抽象类中的方法）
38：java三大要点，一是面向对象，二是集合，三是io 多态的前提 一有继承关系，二有方法的重写，三要有父类的引用指向子类的对象
    多态的弊端就是不能使用子列的属性和行为（方法） 
39：接口中所有的方法的是抽象的
40：一个抽象类中没有抽象方法有没有意义？有，这样做的目的只有一个，就是不让其他类创建本类的对象，交给子类完成
41：定义接口用interface+接口名+{}，调用接口用implements  接口不能实列化，因为接口中的所有方法都是抽象方法（调用抽象方法没有意义）
42：在接口中定义的变量都是常量即使不加final他也会给你加上（都会加上 public static final），
    在子类中不能修改接口中的常量（变量）方法可以直接定义成 void print（）;系统默认家abstract
43: 接口中没有构造函数，实现接口的类中默认的super（）是访问Object（所有类的父类）中的构造方法
44：类与类是继承关系，只能单继承，不能多继承，支持多层继承；
    类与接口是实现关系，可以单实现也可以多实现，并且可以继承和在多实现；
    接口与接口是继承关系，可以多继承
45：包其实就是文件夹将字节码文件分类存储存放字节码文件的（分类管理字节码文件）
46：内部类访问特点 a.内部类可以直接访问外部类的成员，包括私有。
                   b.外部类要访问内部类的成员，必须创建对象。（外部类名.内部类名 对象名=外部类对象.内部类对象）Outer.Inner oi=new Outer().new Inner();
47: 局部内部类定义在方法中的类，其方法中的局部变量必须是final修饰。加载的时候进入（常量池也是方法区的一部分）这样当方法弹栈时局部变量就不会随之消失；
48：匿名内部类只针对从写一个方法时
    链式变成，每次调用方法后还能调用方法证明调用方法返回的是对象
49.封装的好处封装就是隐藏实现细节，只提供公共的访问方式，提高了代码的复用性，提高了安全性
50：面向对象：  就是面向过程和面向对象，
                面向对象的思想a.是一种更符合我们思想习惯的思想 b.可以将复杂的事情简单化 c.将我们从执行者变成了指挥者
   特征：封装，继承，多态
51:在eclipse中的工作空间中src存放源文件，在bin（生成.class文件）中存放字节码文件
52：eclipse使用快捷I：alt+shift+s(快速生成o造)  alt+shift+r(快速生成get,set方法)
53：jar文件是多class文件的嚎s包。作用就是可以用e人好的|西

###11.06_Java开发工具(Eclipse中快捷键的使用)(掌握)
* A:新建 ctrl + n
* B:格式化  ctrl+shift+f
* C:导入包  ctrl+shift+o 
* D:注释  ctrl+/,ctrl+shift+/,ctrl+shift+\
* E:代码上下移动 选中代码alt+上/下箭头
* F:查看源码  选中类名(F3或者Ctrl+鼠标点击)
* G:查找具体的类 ctrl + shift + t
* H:查找具体类的具体方法 ctrl + o
* I:给建议 ctrl+1,根据右边生成左边的数据类型,生成方法
* J:删除代码 ctrl + d
* K:抽取方法alt + shift + m 
* L:改名alt + shift + r 
* 

###11.07_Java开发工具(Eclipse中如何提高开发效率)(掌握)
* alt + shift + s
* A:自动生成构造方法
* B:自动生成get/set方法
54：for循h绦型戤后，Y面O置的量i被放掉了
55：tostring方法作用是更方便的@示傩灾担如果直接打印ο蟮囊用，默J{用tostring方法
56：==既可以比^基本型（比^的是值），也可以比^引用型（比^的是地址值）equals}能比^t用型
    在]有重equalsr，比^的是地址值比^依底拥==，重之後可以比^ο笾械傩
57：StringBuffer是线程安全的可变序列，String是不可变的字符串序列
    StringBuffer转换成String类型的可以用toString方法String转换成StringBuffer可以用append（）方法也都可以通过构造方法来转换
58：Arrays是一个静态类，通过类名就可以调用其中的大量关于数组的方法，需要导包
59：正则表达式：是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串，其实就是一种规则，有自己特殊的应用 比如邮箱的注册，
60：colletion接口有两个接口List，set而List有ArrayList（底层是数组）,LinkedList（底层是链表）,vecter（和    ArrayList一样） set有HashSet（哈希算法）TreeSet（二叉树算法）List有序（存和取的顺序一致）有索引可以存储重复，
    Set无序（存和取的顺序不一致），无索引不可以存储重复
61：自定义异常就是为了区分在报错时爆出的是什么异常不至于都是exception异常
62：finaly时一定会执行的（作用就是释放资源你如io流，）除非在finaly前面关掉jvm->system.exit(0);
63: FileOutputStream fos=new FileOutStream("yyy.txt",true(蓄写，就是不删除之前写入的资源，在后面追加新输入的资源));
64.byte[] arr=new byte[fis.availasbse]一会读取文件大小的字节
   fis.read(arr);fos.write(arr)
   数组中的长度给计算机的内存有关（最快好像是170多兆）
65：inputStream和OutputStream都是抽象类，其之类是fileinputStream和fileoutputStream
    BufferInputSteam bis=new BufferInputSteam(new FileInputStream(""))创建缓冲区对象对输出    流进行包装，使其效率更高BufferInputStream是减少了文件在硬盘中的传说，增加了在内存中的传    送buffer会在内存中创建一个数组，向文件中提取一定的字节，然后每回区时不需要去文件中，而是    在内存中，直到一次把内存中的字节别取完，内存中的数组在操作文件读取一定的字节    BuffterOutStream一次性的把数据从内存缓冲区写入
66.程序计数器：指向当前线程正在执行的字节码指令的地址，行号
      虚拟机栈：存储当前线程运行方法所需要的数据，指令，返回地址
      本地方法栈：为jvm提供native方法
      方法区：存放类信息，常量，静态变量，jit(动态代理生成的一些类的信息)
      堆：jvm的内存模型
67：类的装载：加载，连接（验证，准备解析），初始化，使用，卸载
68：public:具有最大访问权限。 可以被同一项目下的任何类所调用，一般用于对外的情况。
protected:与public不同的是不同包下的类是不能使用的，但是其子孙类除外。所以我认为这是特意为子类设计的。
default:它是针对本包设计的，它所修饰的在本包下的其他类都访问。
private:只为类本身提供。是一种封装的体现。
69.ResourceBundle与Properties的区别在于ResourceBundle通常是用于国际化的属性配置文件读取，Properties则是一般的属性配置文件读取。
70.instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为     boolean result = obj instanceof Class（Class代表一个类或者接口）
71.ArrayList<Interger>加入一个字符串类型的数据，泛型只在java文件编译时检查，在运行时会擦错掉泛型，用反射可以加入

















